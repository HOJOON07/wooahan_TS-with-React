# 3장 고급 타입

## 3.1 독자적 타입 시스템

### any타입

- 모든 값을 오류 없이 받을 수 있다.
- 타입을 명시하지 않은 것과 동일하다.
- any를 사용하는 것은 지양해야 할 패턴으로 알려져 있다.
- `tsconfig.json`의 `noImplicitAny` 옵션을 활성하면 any사용을 막을 수 있다.
- any를 굳이 사용해야 할 때
  1. 개발 중 임시로 값을 지정할 때
  2. 주고 받는 값이 명확하지 않을 때
  3. 값을 예측할 수 없을 때 => unknown으로 대체 가능

### unknown

- unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속성에 접근할 수 없다.
- any와 유사하지만, 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있어 타입안정성이 높다.

### void

- 함수가 값을 반환하지 않는 경우 void로 지정

### never

- 값을 반환할 수 없는 타입
  - 에러를 던지는 경우
  - 무한히 실행되는 함수
- 모든 타입의 하위 타입
- 암격한 타입 검사 목적으로 never를 사용

### Array

- 자료형이 아닌 객체에 속하는 타입으로 본다.

```js
const arr = [];

typeof arr; // 'object'

// 객체의 인스턴스까지 알려주기 때문에 명시적으로 Array임을 알려줌
Object.prototype.toString.call(arr); // [obejct Array]
```

- 표현방법

  ```ts
  // [] 사용하는 법
  type Arr = string[];

  // 제네릭을 사용하는 법
  type ArrString = Array<string>;
  ```

- 사전에 허용하지 않는 타입이 서로 섞이는 것을 방지
- 튜플을 표현 가능, 원소 갯수와 타입을 보장

### enum

- 문자열 상수를 생성하는 데 사용
- enum을 타입으로 하는 변수는 해당 enum의 모든 멤버를 값을 받을 수 있다.
- 즉시실행함수를 통해 양방향 맵핑되어 키와 값으로 모두 접근 가능하다.
- `const enum`으로 역방향 접근을 막을 수 있다. 객체 동작과 유사하게 된다.
- `const enum`을 사용하면 컴파일 타임에 코드에 합쳐지게 된ㄴ다.
- 상수 상수의 경우 선언한 값 이외의 값을 할당하거나 접근이 가능하여 타입안정성이 떨어진다.
- 문자열 상수 방식으로 열거형을 사용하는 것이 숫자 상수보다 안전하고, 의도하지 않는 값의 할당이나 접근을 방지 할 수 있다.

<br />

## 3.2 타입 조합

### 1. Intersection

- 여러 가지 타입을 결합하여 하나의 단일 타입으로 생성
- `&`를 사용

### 2. Union

- 여러 타입 중 하나가 될 수 있는 타입을 생성
- `|`를 사용

### 3. Index Signatures

- 특정 타입의 속성 이름은 알 수 없지만 속성 값의 타입을 알고 있을 때 사용
- `[Key: K]: T` 형태로 표현
- 인덱스 시그니처와 함께 다른 속성을 추가로 명시할 수 있음. 단 인덱스 시그니처의 조건에 포함되어야 함.

### 4. Indexed Access Types

- 다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용
- 인덱스에 사용되는 타입에 유니온, keyof, 타입 별칭 등 사용 가능
  ```ts
  type Indexed = Example[keyof Example];
  ```
- 배열의 요소 타입을 조회하기 위해 사용

  ```ts
  type ElementOf<T> = (typeof T)[number];

  // PromotionList의 요소 타입을 가져온다.
  type PromotionItemType = ElementOf<PromotionList>;
  ```

### 5. Mapped Types

- 유사한 형태를 가진 여러 항목의 목록 A를 변환된 항목 B로 바꾸는 타입

  ```ts
  // T의 내부요소들을 optional 하게 맵핑해버린다
  type Subset<T> = {
    [K in keyof T]?: T[K];
  };

  // -를 사용해 반대로도 가능하다
  type Subset<T> = {
    [K in keyof T]-?: T[K];
  };
  ```

- as 키워드를 사용하여 키를 재지정 할 수 있다.
  ```ts
  type Example = {
    [index in Some as `${index}_some`]: {
      // ...
    };
  };
  ```

### 6. Template Literal Types

- 템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입g을 선언할 수 있다
  ```ts
  type Stage = "first" | "second";
  type StageName = `${Stage}-stage`;
  // first-stage | second-stage
  ```

### 7. 제네릭

- 다양한 타입 간에 재사용성을 높이기 위해 사용하는 문법
- 타입 생성 시점에 원하는 타입으로 특정할 수 있다.
- 제네릭 함수를 호출 할 때 반드시 제네릭을 명시할 필요는 없다. (컴파일러가 추론해줌)
- `extends`를 통해서 제네릭의 타입을 제약할 수 있다.
- 함수에서 제네릭을 사용할 때는 `function`을 사용하는 경우가 많다.

<br />

## 3.3 제네릭 사용법

### 함수의 제네릭

- 어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때

### 호출 시그니처의 제네릭

\* 호출 시그니처: 함수의 매개변수와 반환 타입을 미리 선언하는 것

### 제네릭 클래스

- 외부에서 입력된 타입을 클래스 내부에서 적용 할 수 있다.

### 제한된 제네릭

- 타입 매개변수에 대한 제약 조건을 설정할 수 있다.
- 제네릭이 특정 타입을 상속하도록 설정하면 제약할 수 있다.
- 기본타입, 인터페이스, 클래스, 유니온 타입을 모두 상속할 수 있다.

### 확장된 제네릭

- 여러 타입을 상속할 수 있다.
- 제네릭 매개변수를 여러개 둘 수 있다.
